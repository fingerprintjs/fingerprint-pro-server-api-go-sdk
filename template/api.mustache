
{{>partial_header}}
package {{packageName}}

{{#operations}}
import (
    "context"
    "net/http"
    "strings"
)

const IntegrationInfo = "fingerprint-pro-server-go-sdk/{{packageVersion}}"

type {{classname}}ServiceInterface interface {
{{#operation}}
        /*
    {{{classname}}}Service{{#summary}} {{.}}{{/summary}}{{#notes}}
    {{{notes}}}{{/notes}}
     * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
    {{#allParams}}{{#required}} * @param {{paramName}}{{#description}} {{{.}}}{{/description}}
    {{/required}}{{/allParams}}{{#hasOptionalParams}} * @param opts nil or *{{{classname}}}{{{nickname}}}Opts - Optional Parameters:
    {{#allParams}}{{^required}}     * @param "{{vendorExtensions.x-exportParamName}}" ({{#isPrimitiveType}}{{dataType}}{{/isPrimitiveType}}{{^isPrimitiveType}}Interface of {{dataType}}{{/isPrimitiveType}}) - {{#description}} {{{.}}}{{/description}}
    {{/required}}{{/allParams}}{{/hasOptionalParams}}
    {{#returnType}}@return {{{returnType}}}{{/returnType}}
    */
    {{{nickname}}}(ctx context.Context{{#hasParams}}, {{/hasParams}}{{#allParams}}{{#required}}{{paramName}} {{{dataType}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}}opts *{{{classname}}}{{{nickname}}}Opts{{/hasOptionalParams}}) ({{#returnType}}{{{returnType}}}, {{/returnType}}*http.Response, Error)

{{/operation}}
}

type requestDefinition struct {
    StatusCodeResultsFactoryMap map[int]func() any
    GetPath             func(params ...string) string
}

{{#operation}}
func create{{nickname}}Definition() requestDefinition {
    return requestDefinition{
        GetPath: func(args ...string) string {
            pathParams := []string{ {{#pathParams}}"{{baseName}}",{{/pathParams}} }

            path := "{{{path}}}"

            for i, arg := range args {
                path = strings.Replace(path, "{"+pathParams[i]+"}", arg, -1)
            }

            return path
        },
        StatusCodeResultsFactoryMap: map[int]func() any{
            {{#responses}}{{#dataType}}
            {{code}}: func() any { return &{{{dataType}}}{} },
            {{/dataType}}{{/responses}}
        },
    }
}

{{#hasOptionalParams}}

    type {{{classname}}}{{{nickname}}}Opts struct {
    {{#allParams}}{{^required}}
        {{#isPrimitiveType}}    {{vendorExtensions.x-exportParamName}} {{^vendorExtensions.x-go-skip-pointer}}{{^required}}*{{/required}}{{/vendorExtensions.x-go-skip-pointer}}{{dataType}}{{/isPrimitiveType}}{{^isPrimitiveType}}    {{vendorExtensions.x-exportParamName}} any{{/isPrimitiveType}}
    {{/required}}{{/allParams}}
    }

    func (o *{{{classname}}}{{{nickname}}}Opts) ToQueryParams() map[string]any {
        data := make(map[string]any)

        if o == nil {
            return data
        }

        {{#allParams}}{{^required}}
            {{#isPrimitiveType}} data["{{baseName}}"] = o.{{vendorExtensions.x-exportParamName}} {{/isPrimitiveType}}
            {{^isPrimitiveType}}
            {
                v := any(o.{{vendorExtensions.x-exportParamName}})
                var out []string

                switch vv := v.(type) {
                case string:
                    if vv != "" {
                        out = []string{vv}
                    }
                case *string:
                    if vv != nil && *vv != "" {
                        out = []string{*vv}
                    }
                case []string:
                    if len(vv) > 0 {
                        out = vv
                    }
                case *[]string:
                    if vv != nil && len(*vv) > 0 {
                        out = *vv
                    }
                case []any:
                    // accept only if all elements are strings or *string
                    tmp := make([]string, 0, len(vv))
                    ok := true
                    for _, e := range vv {
                        switch s := e.(type) {
                        case string:
                            tmp = append(tmp, s)
                        case *string:
                            if s != nil {
                                tmp = append(tmp, *s)
                            } else {
                                ok = false
                            }
                        default:
                            ok = false
                        }
                        if !ok {
                            break
                        }
                    }
                    if ok && len(tmp) > 0 {
                        out = tmp
                    }
                default:
                    // unsupported -> skip
                }

                if len(out) > 0 {
                    data["{{baseName}}"] = out
                }
            }
            {{/isPrimitiveType}}
        {{/required}}{{/allParams}}

        return data
    }


{{/hasOptionalParams}}
{{/operation}}{{/operations}}
